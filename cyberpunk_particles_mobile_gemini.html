<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyberpunk Hand Particles - Gemini 3</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', monospace;
            user-select: none;
            touch-action: none;
        }

        /* 赛博朋克背景网格与扫描线 */
        #background-fx {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        
        /* 扫描线动画 */
        #scanline {
            width: 100%;
            height: 100px;
            z-index: 1;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 255, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }

        /* 暗角效果 */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: 0 0 150px rgba(0,0,0,0.9) inset;
            pointer-events: none;
            z-index: 2;
        }

        /* HUD 界面 */
        .hud-panel {
            position: absolute;
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            padding: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 10, 20, 0.6);
            backdrop-filter: blur(2px);
        }

        #hud-tl { top: 20px; left: 20px; border-top-left-radius: 10px; }
        #hud-tr { top: 20px; right: 20px; border-top-right-radius: 10px; text-align: right; }
        #hud-bl { bottom: 20px; left: 20px; border-bottom-left-radius: 10px; }
        #hud-br { bottom: 20px; right: 20px; border-bottom-right-radius: 10px; text-align: right; }

        .label {
            font-size: 10px;
            color: rgba(0, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .value {
            font-size: 18px;
            font-weight: bold;
        }
        .status-active { color: #f0f; text-shadow: 0 0 5px #f0f; }
        .instruction { color: #ff0; font-size: 12px; margin-top: 5px; opacity: 0.8; }

        #canvas-container {
            width: 100%;
            height: 100vh;
        }

        /* 摄像头权限/状态面板 */
        #camera-panel {
            position: absolute;
            left: 50%;
            top: 16px;
            transform: translateX(-50%);
            z-index: 30;
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px 12px;
            border: 1px solid rgba(0, 255, 255, 0.35);
            background: rgba(0, 10, 20, 0.75);
            backdrop-filter: blur(3px);
            border-radius: 10px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            font-size: 12px;
            max-width: min(92vw, 720px);
        }
        #camera-btn {
            appearance: none;
            border: 1px solid rgba(0, 255, 255, 0.45);
            background: rgba(0, 255, 255, 0.08);
            color: #0ff;
            padding: 8px 10px;
            border-radius: 10px;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            cursor: pointer;
        }
        #camera-btn:active {
            transform: translateY(1px);
        }
        #camera-status {
            opacity: 0.9;
            line-height: 1.35;
        }

        /* 相机预览小窗（方案A：右下角） */
        #video {
            position: fixed;
            right: 14px;
            bottom: 14px;
            width: min(36vw, 220px);
            height: auto;
            aspect-ratio: 4 / 3;
            opacity: 0.85;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.35);
            box-shadow: 0 0 18px rgba(0, 255, 255, 0.15);
            z-index: 25;
            pointer-events: none; /* 避免遮挡触摸交互 */
        }

        /* MediaPipe 手势识别展示（右上角） */
        #mp-panel {
            position: absolute;
            top: 94px; /* 避开右上 HUD（#hud-tr） */
            right: 20px;
            z-index: 12;
            width: min(42vw, 260px);
            padding: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 10, 20, 0.6);
            backdrop-filter: blur(2px);
            border-radius: 10px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            pointer-events: none;
        }
        #mp-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 4 / 3;
            display: block;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.18);
            background: rgba(0, 0, 0, 0.25);
        }
        #mp-text {
            margin-top: 8px;
            font-size: 11px;
            line-height: 1.35;
            opacity: 0.9;
            white-space: pre-line;
        }
    </style>
</head>
<body>

    <div id="background-fx"></div>
    <div id="scanline"></div>
    <div id="vignette"></div>

    <!-- 相机面板：移动端/微信里必须“点击按钮”才会弹出相机授权 -->
    <div id="camera-panel">
        <button id="camera-btn" type="button">启用相机手势</button>
        <div id="camera-status">未启用相机（当前使用键盘/鼠标/触摸）。</div>
    </div>

    <video id="video" autoplay playsinline muted></video>

    <!-- HUD Elements -->
    <div id="hud-tl" class="hud-panel">
        <div class="label">SYSTEM STATUS</div>
        <div id="fps-counter" class="value">60 FPS</div>
        <div class="label">PARTICLES</div>
        <div class="value">25,000 UNIT</div>
    </div>

    <div id="hud-tr" class="hud-panel">
        <div class="label">LEFT HAND (CMD)</div>
        <div id="left-hand-status" class="value">IDLE</div>
        <div class="instruction">KEYS: 1, 2, 3, 4, 5</div>
    </div>

    <!-- 右上角：MediaPipe 手势识别展示 -->
    <div id="mp-panel">
        <div class="label">MEDIAPIPE HANDS</div>
        <canvas id="mp-canvas" width="320" height="240"></canvas>
        <div id="mp-text">未启用相机</div>
    </div>

    <div id="hud-bl" class="hud-panel">
        <div class="label">INTERACTION MODE</div>
        <div id="interaction-mode" class="value">SCATTER</div>
        <div class="instruction">SPACEBAR: NEBULA/RIPPLE</div>
    </div>

    <div id="hud-br" class="hud-panel">
        <div class="label">RIGHT HAND (PHYSICS)</div>
        <div id="right-hand-status" class="value">INDEX FINGER</div>
        <div class="instruction">MOUSE: TRACKING</div>
    </div>

    <div id="canvas-container"></div>

    <!-- MediaPipe Hands（需要 HTTPS 才能在手机正常拉起相机权限） -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 全局配置 ---
        const CONFIG = {
            particleCount: 25000,  // 增加粒子数量以提高密度 (原12000)
            particleSize: 2.2,     // 稍微调小一点点，避免高密度下过于拥挤
            returnSpeed: 0.16,
            scatterForce: 50,      // 强力散开力度
            rippleAmplitude: 30,   // 水波纹幅度
            textFontSize: 120,     // 文字扫描字号
            colors: {
                blue: new THREE.Color(0x00FFFF),
                yellow: new THREE.Color(0xFFFF00),
                pink: new THREE.Color(0xFF00FF),
                green: new THREE.Color(0x00FF88),
                orange: new THREE.Color(0xFF8800),
                default: new THREE.Color(0x00FFFF)
            }
        };

        // --- 状态管理 ---
        const STATE = {
            leftHandMode: 1, // 1, 2, 3, 4, 5
            rightHandOpen: false, // controlled by Spacebar
            mouseX: 0,
            mouseY: 0,
            simulatedLeftHandPos: new THREE.Vector3(-200, 0, 0), // 左手盛接位置
            isBasketballMode: false,
            // 相机/手势
            cameraActive: false,
            handsDetected: false
        };

        // --- Three.js 核心变量 ---
        let scene, camera, renderer, particles, geometry;
        let originalPositions = []; // 目标位置缓存
        let currentPositions = [];  // 当前物理位置
        let particleColors = [];    // 颜色数据
        let targetPositions = [];   // 目标位置
        let bounceOffsets = [];     // 篮球弹跳偏移量
        
        // 字体画布
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');
        textCanvas.width = 1024;
        textCanvas.height = 512;

        // --- 相机/手势（MediaPipe） ---
        let hands = null;
        let mpCamera = null;
        const MP = {
            canvas: null,
            ctx: null,
            textEl: null
        };

        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        function setCameraStatus(text) {
            const el = document.getElementById('camera-status');
            if (el) el.textContent = text;
        }

        function setMpText(text) {
            if (!MP.textEl) MP.textEl = document.getElementById('mp-text');
            if (MP.textEl) MP.textEl.textContent = text;
        }

        function ensureMpCanvas() {
            if (!MP.canvas) MP.canvas = document.getElementById('mp-canvas');
            if (!MP.ctx && MP.canvas) MP.ctx = MP.canvas.getContext('2d');
        }

        // 计算伸直手指数（简单规则：拇指比较 x，其余比较 y）
        function countFingersUp(landmarks, handednessLabel) {
            if (!landmarks || landmarks.length < 21) return 0;
            const tips = [4, 8, 12, 16, 20];
            const joints = [3, 6, 10, 14, 18];
            let count = 0;

            // 拇指：左右手方向相反
            const thumbTipX = landmarks[tips[0]].x;
            const thumbJointX = landmarks[joints[0]].x;
            if (handednessLabel === 'Left') {
                if (thumbTipX < thumbJointX) count++;
            } else {
                if (thumbTipX > thumbJointX) count++;
            }

            // 其他四指：tip.y 更小表示更“向上”（未镜像时通常成立）
            for (let i = 1; i < 5; i++) {
                if (landmarks[tips[i]].y < landmarks[joints[i]].y) count++;
            }
            return count;
        }

        function drawHandsOnMpCanvas(results) {
            ensureMpCanvas();
            if (!MP.ctx || !MP.canvas) return;

            const ctx = MP.ctx;
            ctx.clearRect(0, 0, MP.canvas.width, MP.canvas.height);

            if (!results || !results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                // 轻微网格背景，避免空白
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.strokeStyle = 'rgba(0,255,255,0.25)';
                for (let x = 0; x <= MP.canvas.width; x += 32) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, MP.canvas.height); ctx.stroke();
                }
                for (let y = 0; y <= MP.canvas.height; y += 24) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(MP.canvas.width, y); ctx.stroke();
                }
                ctx.restore();
                return;
            }

            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const lm = results.multiHandLandmarks[i];
                const handed = results.multiHandedness && results.multiHandedness[i] ? results.multiHandedness[i].label : 'Unknown';
                const color = handed === 'Left' ? 'rgba(0,255,255,0.9)' : 'rgba(255,0,255,0.9)';

                // 画连接线
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.55;
                for (const [a, b] of HAND_CONNECTIONS) {
                    const pa = lm[a], pb = lm[b];
                    ctx.beginPath();
                    ctx.moveTo(pa.x * MP.canvas.width, pa.y * MP.canvas.height);
                    ctx.lineTo(pb.x * MP.canvas.width, pb.y * MP.canvas.height);
                    ctx.stroke();
                }
                ctx.restore();

                // 画关键点
                ctx.save();
                ctx.fillStyle = color;
                for (let j = 0; j < lm.length; j++) {
                    const p = lm[j];
                    const x = p.x * MP.canvas.width;
                    const y = p.y * MP.canvas.height;
                    ctx.beginPath();
                    ctx.arc(x, y, (j === 8 ? 4 : 2.5), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        function isSecureContextForCamera() {
            // GitHub Pages/https 才能在大多数手机浏览器 & 微信里弹出相机授权
            return window.isSecureContext || location.hostname === 'localhost';
        }

        async function startCameraGestureMode() {
            if (!isSecureContextForCamera()) {
                setCameraStatus('无法启用：需要 HTTPS 才能请求相机权限（请用 GitHub Pages 打开）。');
                return;
            }

            const video = document.getElementById('video');
            if (!video) return;

            // 注意：这里必须由“用户点击”触发，手机才会弹相机授权
            try {
                // 先手动请求一次权限，确保弹窗出现
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
                video.srcObject = stream;
                await video.play();

                // 初始化 MediaPipe Hands
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
                });
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });
                hands.onResults(onHandsResults);

                mpCamera = new Camera(video, {
                    onFrame: async () => {
                        if (!hands) return;
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                await mpCamera.start();

                STATE.cameraActive = true;
                setCameraStatus('相机已启用：正在检测双手（若无画面/无提示，检查微信权限设置）。');
                setMpText('相机已启用：等待手进入画面…');
            } catch (err) {
                console.log(err);
                STATE.cameraActive = false;
                setCameraStatus('相机启用失败/被拒绝：继续使用键盘/鼠标/触摸。');
                setMpText('相机启用失败/被拒绝');
            }
        }

        function onHandsResults(results) {
            const hasHands = !!(results && results.multiHandLandmarks && results.multiHandLandmarks.length);
            STATE.handsDetected = hasHands;
            if (STATE.cameraActive) {
                setCameraStatus(hasHands ? '相机已启用：已检测到手（手势控制已接入）。' : '相机已启用：未检测到手（把手放到镜头前）。');
            }

            // 右上角展示：画关键点 + 显示左右手伸指数
            drawHandsOnMpCanvas(results);

            if (!STATE.cameraActive) {
                setMpText('未启用相机');
                return;
            }

            if (!hasHands) {
                setMpText('未检测到手\n提示：把手放到镜头前，保持光线充足');
                return;
            }

            let leftCount = null;
            let rightCount = null;
            let leftLandmarks = null;
            let rightLandmarks = null;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const handed = results.multiHandedness && results.multiHandedness[i] ? results.multiHandedness[i].label : 'Unknown';
                    const landmarks = results.multiHandLandmarks[i];
                    const count = countFingersUp(landmarks, handed);
                    
                    if (handed === 'Left') {
                        leftCount = count;
                        leftLandmarks = landmarks;
                    }
                    if (handed === 'Right') {
                        rightCount = count;
                        rightLandmarks = landmarks;
                    }
                }
            }

            // 映射手势到粒子控制状态
            if (STATE.cameraActive && hasHands) {
                // 左手：根据手指数更新模式 (1-5)
                if (leftCount !== null && leftCount >= 1 && leftCount <= 5) {
                    if (STATE.leftHandMode !== leftCount) {
                        STATE.leftHandMode = leftCount;
                        updateLeftHandState();
                    }
                    // 更新左手位置（使用手腕位置，landmark[0]）
                    if (leftLandmarks && leftLandmarks[0]) {
                        const wrist = leftLandmarks[0];
                        // MediaPipe 坐标是归一化的 (0-1)，转换为 Three.js 坐标
                        // 假设视频是 640x480，映射到屏幕坐标再转换
                        const x = (wrist.x - 0.5) * window.innerWidth * 2;
                        const y = -(wrist.y - 0.5) * window.innerHeight * 2;
                        STATE.simulatedLeftHandPos.set(x, y, 0);
                    }
                }

                // 右手：根据手指数判断是否张开（>=4指视为张开）
                if (rightCount !== null) {
                    const isOpen = rightCount >= 4;
                    if (STATE.rightHandOpen !== isOpen) {
                        STATE.rightHandOpen = isOpen;
                        updateRightHandState();
                    }
                    // 更新右手交互点（使用食指指尖，landmark[8]）
                    if (rightLandmarks && rightLandmarks[8]) {
                        const indexTip = rightLandmarks[8];
                        const x = (indexTip.x - 0.5) * window.innerWidth * 2;
                        const y = -(indexTip.y - 0.5) * window.innerHeight * 2;
                        STATE.mouseX = x;
                        STATE.mouseY = y;
                    }
                }
            }

            const lines = [];
            lines.push(`检测到手: ${results.multiHandLandmarks.length} / 2`);
            lines.push(`Left: ${leftCount === null ? '-' : leftCount} fingers → Mode ${STATE.leftHandMode}`);
            lines.push(`Right: ${rightCount === null ? '-' : rightCount} fingers → ${STATE.rightHandOpen ? 'OPEN' : 'SCATTER'}`);
            lines.push(`STATE.leftHandMode: ${STATE.leftHandMode}`);
            lines.push(`STATE.rightHandOpen: ${STATE.rightHandOpen ? 'OPEN' : 'SCATTER'}`);
            setMpText(lines.join('\n'));
        }

        // 初始化
        function init() {
            const container = document.getElementById('canvas-container');
            
            // 场景
            scene = new THREE.Scene();
            // 稍微加一点雾气增强景深
            scene.fog = new THREE.FogExp2(0x000000, 0.0005);

            // 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 800;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // 创建粒子系统
            createParticles();

            // 生成初始目标 (Mode 1: Hello)
            generateTextTarget("Hello", CONFIG.colors.blue);

            // 事件监听
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            // 相机按钮：必须点击才能弹授权
            const btn = document.getElementById('camera-btn');
            if (btn) btn.addEventListener('click', startCameraGestureMode);

            // 初始化右上角面板
            ensureMpCanvas();
            setMpText('未启用相机');

            // 轻提示：非 https 时告诉用户原因
            if (!isSecureContextForCamera()) {
                setCameraStatus('提示：当前非 HTTPS，手机/微信通常不会弹相机授权。请用 GitHub Pages(HTTPS) 打开。');
                setMpText('提示：需要 HTTPS 才能启用相机');
            }

            // 动画循环
            animate();
        }

        // 创建粒子
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // 初始随机位置 (Nebula style)
                positions[i * 3] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 1000;

                colors[i * 3] = CONFIG.colors.blue.r;
                colors[i * 3 + 1] = CONFIG.colors.blue.g;
                colors[i * 3 + 2] = CONFIG.colors.blue.b;

                sizes[i] = CONFIG.particleSize;

                // 初始化物理数组
                currentPositions.push(new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]));
                targetPositions.push(new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]));
                bounceOffsets.push(0);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 材质
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        // 简单的圆形发光粒子
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        // 边缘柔化
                        float alpha = 1.0 - (r * 2.0);
                        alpha = pow(alpha, 1.5); 
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 目标生成逻辑 ---

        // 1. 文字生成 (Canvas 扫描法)
        function generateTextTarget(text, color) {
            STATE.isBasketballMode = false;
            
            // 清空并绘制文字
            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            textCtx.font = `bold ${CONFIG.textFontSize}px "Microsoft YaHei", sans-serif`; // 支持中文
            textCtx.fillStyle = '#FFFFFF';
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            textCtx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            const imageData = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
            const data = imageData.data;
            const validPixels = [];

            // 扫描像素 - 提高精度：step 2 (原为4)
            for (let y = 0; y < textCanvas.height; y += 2) { 
                for (let x = 0; x < textCanvas.width; x += 2) {
                    const index = (y * textCanvas.width + x) * 4;
                    if (data[index] > 128) { // 亮度阈值
                        validPixels.push({
                            x: (x - textCanvas.width / 2) * 3, // 缩放因子
                            y: -(y - textCanvas.height / 2) * 3
                        });
                    }
                }
            }

            updateTargets(validPixels, color);
        }

        // 2. 星云模式 (全屏散布)
        function generateNebulaTarget() {
            STATE.isBasketballMode = false;
            const nebulaTargets = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                nebulaTargets.push({
                    x: (Math.random() - 0.5) * window.innerWidth * 1.5,
                    y: (Math.random() - 0.5) * window.innerHeight * 1.5,
                    z: (Math.random() - 0.5) * 500
                });
            }
            // 保持当前颜色或设为默认
            updateTargets(nebulaTargets, null, true); 
        }

        // 3. 篮球模式 (斐波那契球面 + 弹跳轨迹预设)
        function generateBasketballTarget() {
            STATE.isBasketballMode = true;
            const radius = 120; // 篮球半径
            const targets = [];
            const phi = Math.PI * (3 - Math.sqrt(5)); // 黄金角

            const offset = STATE.simulatedLeftHandPos; // 汇聚到左手

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const y = 1 - (i / (CONFIG.particleCount - 1)) * 2; // y goes from 1 to -1
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = phi * i;

                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;

                // 纹理模拟：黑线区域粒子少或颜色深 (简单模拟：根据坐标排除切片)
                // 这里为了视觉完整，不做复杂纹理剔除，而是用颜色纹理
                
                targets.push({
                    x: x * radius + offset.x,
                    y: y * radius + offset.y,
                    z: z * radius + offset.z
                });

                // 设置弹跳随机相位
                bounceOffsets[i] = Math.random() * Math.PI; 
            }
            
            // 橙色为主，混入黑色线条颜色
            updateTargets(targets, CONFIG.colors.orange, false, true);
        }

        // 更新目标位置数组
        function updateTargets(validPoints, color, isNebula = false, isBasketball = false) {
            const colorAttr = geometry.attributes.color;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // 目标位置分配
                let target;
                if (validPoints.length > 0) {
                    const p = validPoints[i % validPoints.length];
                    target = isNebula ? p : { x: p.x, y: p.y, z: p.z || 0 };
                } else {
                    target = { x: 0, y: 0, z: 0 };
                }
                
                targetPositions[i].set(target.x, target.y, target.z || 0);

                // 颜色更新
                if (color) {
                    let c = color;
                    // 篮球纹理处理
                    if (isBasketball) {
                        // 简单的条纹生成逻辑
                        const p = targetPositions[i];
                        const localY = p.y - STATE.simulatedLeftHandPos.y;
                        const localX = p.x - STATE.simulatedLeftHandPos.x;
                        if (Math.abs(localY) < 5 || Math.abs(localX) < 5) {
                            c = new THREE.Color(0x111111); // 黑线
                        } else {
                            c = CONFIG.colors.orange;
                        }
                    }

                    colorAttr.setXYZ(i, c.r, c.g, c.b);
                }
            }
            colorAttr.needsUpdate = true;
        }

        // --- 交互处理 ---

        function onMouseMove(event) {
            // 将鼠标坐标转换为 Three.js 坐标系
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // 简单的投影，假设 Z=0
            const vector = new THREE.Vector3(x, y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            STATE.mouseX = pos.x;
            STATE.mouseY = pos.y;
        }

        function onKeyDown(event) {
            const key = event.key;
            
            // 左手逻辑 (1-5)
            if (['1', '2', '3', '4', '5'].includes(key)) {
                STATE.leftHandMode = parseInt(key);
                updateLeftHandState();
            }

            // 右手逻辑 (Space)
            if (event.code === 'Space') {
                if (!STATE.rightHandOpen) {
                    STATE.rightHandOpen = true;
                    updateRightHandState();
                }
            }
        }

        function onKeyUp(event) {
            if (event.code === 'Space') {
                STATE.rightHandOpen = false;
                updateRightHandState();
            }
        }

        function updateLeftHandState() {
            const mode = STATE.leftHandMode;
            const hud = document.getElementById('left-hand-status');

            // 检查组合技
            if (checkCombo()) return;

            switch(mode) {
                case 1:
                    generateTextTarget("Hello", CONFIG.colors.blue);
                    hud.innerText = "1 FINGER (HELLO)";
                    hud.style.color = '#0ff';
                    break;
                case 2:
                    generateTextTarget("Gemini3", CONFIG.colors.yellow);
                    hud.innerText = "2 FINGERS (MODEL)";
                    hud.style.color = '#ff0';
                    break;
                case 3:
                    generateTextTarget("非常好用", CONFIG.colors.pink);
                    hud.innerText = "3 FINGERS (PRAISE)";
                    hud.style.color = '#f0f';
                    break;
                case 4:
                    generateTextTarget("再见", CONFIG.colors.green);
                    hud.innerText = "4 FINGERS (BYE)";
                    hud.style.color = '#0f8';
                    break;
                case 5:
                    // 盛接模式：准备接收，但如果右手没张开，则只是清空或维持
                    // 这里设计为先显示一个容器提示，或者保持原状等待
                    generateTextTarget("[  READY  ]", CONFIG.colors.default);
                    hud.innerText = "5 FINGERS (CATCH MODE)";
                    hud.style.color = '#fff';
                    break;
            }
        }

        function updateRightHandState() {
            const hud = document.getElementById('right-hand-status');
            const hudMode = document.getElementById('interaction-mode');
            
            // 检查组合技
            if (checkCombo()) return;

            if (STATE.rightHandOpen) {
                // Nebula / Ripple Mode
                generateNebulaTarget(); 
                hud.innerText = "HAND OPEN";
                hudMode.innerText = "NEBULA / RIPPLE";
                hudMode.className = "value status-active";
            } else {
                // Back to previous text
                updateLeftHandState(); 
                hud.innerText = "INDEX FINGER";
                hudMode.innerText = "SCATTER (PHYSICS)";
                hudMode.className = "value";
            }
        }

        function checkCombo() {
            // 只有当左手为5且右手张开时触发
            if (STATE.leftHandMode === 5 && STATE.rightHandOpen) {
                generateBasketballTarget();
                document.getElementById('interaction-mode').innerText = "ULTIMATE: BASKETBALL";
                document.getElementById('interaction-mode').style.color = "#ff8800";
                return true;
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 核心动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;
            const time = Date.now() * 0.001;
            
            // 右手交互点
            const mousePos = new THREE.Vector3(STATE.mouseX, STATE.mouseY, 0);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let current = currentPositions[i];
                let target = targetPositions[i];

                // 1. 基础运动 (Lerp)
                // 篮球模式下的特殊弹跳轨迹
                if (STATE.isBasketballMode) {
                    // 增加旋转
                    const speed = 2.0;
                    const x = target.x - STATE.simulatedLeftHandPos.x;
                    const z = target.z - STATE.simulatedLeftHandPos.z;
                    // 绕Y轴旋转
                    const rotatedX = x * Math.cos(speed * 0.01) - z * Math.sin(speed * 0.01);
                    const rotatedZ = x * Math.sin(speed * 0.01) + z * Math.cos(speed * 0.01);
                    
                    target.x = rotatedX + STATE.simulatedLeftHandPos.x;
                    target.z = rotatedZ + STATE.simulatedLeftHandPos.z;
                    
                    // 弹跳效果模拟 (实际上在飞入过程中很难模拟单个弹跳，这里做成旋转球体的呼吸效果)
                    const bounce = Math.sin(time * 5 + bounceOffsets[i]) * 5;
                    target.y += bounce * 0.05; 
                }

                current.x += (target.x - current.x) * CONFIG.returnSpeed;
                current.y += (target.y - current.y) * CONFIG.returnSpeed;
                current.z += (target.z - current.z) * CONFIG.returnSpeed;

                // 2. 右手物理交互
                const dist = current.distanceTo(mousePos);
                
                if (STATE.rightHandOpen) {
                    // 状态 B: 涟漪 (Ripple)
                    // 只有当粒子接近右手划过的区域时触发
                    if (dist < 300) {
                        // Z轴波浪
                        current.z += Math.sin(dist * 0.1 - time * 10) * CONFIG.rippleAmplitude * (1 - dist/300);
                    }
                } else {
                    // 状态 A: 强力斥力 (Scatter) - 仅平面推开
                    if (dist < 150) {
                        const force = (150 - dist) / 150;
                        const angle = Math.atan2(current.y - mousePos.y, current.x - mousePos.x);
                        const moveX = Math.cos(angle) * CONFIG.scatterForce * force;
                        const moveY = Math.sin(angle) * CONFIG.scatterForce * force;
                        
                        current.x += moveX;
                        current.y += moveY;
                        // 不改变 Z 轴，保持平面整洁
                    }
                }

                // 更新 Buffer
                positions[i * 3] = current.x;
                positions[i * 3 + 1] = current.y;
                positions[i * 3 + 2] = current.z;
            }

            geometry.attributes.position.needsUpdate = true;

            // 篮球自转整体效果 (通过旋转相机或者整体容器也可以，但这里我们旋转了目标点)
            
            // 更新 HUD FPS (模拟)
            if (Math.random() > 0.95) {
                document.getElementById('fps-counter').innerText = Math.floor(58 + Math.random() * 4) + " FPS";
            }

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>