<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>流体候鸟算法模拟 - 沉浸式生成艺术</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505; /* 深邃星空背景 */
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 215, 0, 0.8); /* 极简金 */
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .instruction {
            font-size: 10px;
            margin-top: 5px;
            opacity: 0.6;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <div style="font-weight: 800; font-size: 18px;">Fluid Migratory Boids</div>
        <div class="instruction">移动鼠标产生引力与风场 | 点击鼠标释放排斥波</div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        /**
         * 基础向量类 (Vector Class)
         * 实现物理计算的核心逻辑
         */
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            setMag(n) { return this.normalize().mult(n); }
            normalize() {
                const m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }
            limit(max) {
                const m = this.mag();
                if (m > max) this.setMag(max);
                return this;
            }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static dist(v1, v2) { return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2); }
            static random() {
                const angle = Math.random() * Math.PI * 2;
                return new Vector(Math.cos(angle), Math.sin(angle));
            }
        }

        /**
         * 候鸟个体类 (Boid Class)
         * 集群算法逻辑与柔性形态绘制
         */
        class Boid {
            constructor(canvasWidth, canvasHeight) {
                this.position = new Vector(Math.random() * canvasWidth, Math.random() * canvasHeight);
                this.velocity = Vector.random().mult(Math.random() * 2 + 2);
                this.acceleration = new Vector();
                this.maxSpeed = 4.5;
                this.maxForce = 0.2;
                this.perceptionRadius = 80;
                this.blindSpotAngle = 1.0; // 弧度，约 60 度的后方盲区
                
                // 存储历史位置以实现自适应软体形态
                this.history = [];
                this.historyLimit = 5;
                
                this.hue = 45; // 默认金黄色
            }

            // 集群行为：分离、对齐、凝聚
            flock(boids, mouse, isClicking) {
                let sep = this.separate(boids);
                let ali = this.align(boids);
                let coh = this.cohesion(boids);
                
                // 权重分配
                sep.mult(1.8);
                ali.mult(1.0);
                coh.mult(1.0);

                this.acceleration.add(sep);
                this.acceleration.add(ali);
                this.acceleration.add(coh);

                // 鼠标引力与风场
                if (mouse.active) {
                    let mouseTarget = new Vector(mouse.x, mouse.y);
                    let force = this.seek(mouseTarget);
                    
                    if (isClicking) {
                        force.mult(-5.0); // 点击产生强烈排斥
                    } else {
                        // 根据鼠标移动速度产生风场扰动
                        const mouseSpeed = Math.min(mouse.speed * 0.5, 2.0);
                        force.mult(1.5 + mouseSpeed);
                    }
                    this.acceleration.add(force);
                }
            }

            // 判断是否在感知范围内（包含盲区逻辑）
            canSee(other) {
                const dist = Vector.dist(this.position, other.position);
                if (dist > 0 && dist < this.perceptionRadius) {
                    // 盲区计算：检查目标是否在正后方
                    const toOther = Vector.sub(other.position, this.position);
                    const angleToOther = Math.atan2(toOther.y, toOther.x);
                    const myAngle = Math.atan2(this.velocity.y, this.velocity.x);
                    let diff = Math.abs(angleToOther - myAngle);
                    if (diff > Math.PI) diff = Math.PI * 2 - diff;
                    
                    return diff < (Math.PI - this.blindSpotAngle);
                }
                return false;
            }

            // 平滑转向力 Steering = Desired - Velocity
            seek(target) {
                let desired = Vector.sub(target, this.position);
                desired.setMag(this.maxSpeed);
                let steer = Vector.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }

            separate(boids) {
                let steering = new Vector();
                let total = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.position, other.position);
                    if (d > 0 && d < 30) {
                        let diff = Vector.sub(this.position, other.position);
                        diff.div(d * d); // 距离越近排斥力越大
                        steering.add(diff);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.div(total);
                    steering.setMag(this.maxSpeed);
                    steering.sub(this.velocity);
                    steering.limit(this.maxForce * 1.5);
                }
                return steering;
            }

            align(boids) {
                let steering = new Vector();
                let total = 0;
                for (let other of boids) {
                    if (this.canSee(other)) {
                        steering.add(other.velocity);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.div(total);
                    steering.setMag(this.maxSpeed);
                    steering.sub(this.velocity);
                    steering.limit(this.maxForce);
                }
                return steering;
            }

            cohesion(boids) {
                let steering = new Vector();
                let total = 0;
                for (let other of boids) {
                    if (this.canSee(other)) {
                        steering.add(other.position);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.div(total);
                    return this.seek(steering);
                }
                return steering;
            }

            update(w, h) {
                // 记录轨迹
                this.history.push(new Vector(this.position.x, this.position.y));
                if (this.history.length > this.historyLimit) this.history.shift();

                this.position.add(this.velocity);
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed);
                this.acceleration.mult(0);

                // 边界环绕
                if (this.position.x > w) this.position.x = 0;
                if (this.position.x < 0) this.position.x = w;
                if (this.position.y > h) this.position.y = 0;
                if (this.position.y < 0) this.position.y = h;

                // 动态颜色计算：基于移动角度变换 HSL
                // 向北 ( -PI/2 ) -> 极光绿 (120-160)
                // 向南 ( PI/2 ) -> 深海蓝 (200-240)
                const angle = Math.atan2(this.velocity.y, this.velocity.x);
                this.hue = ((angle + Math.PI) / (Math.PI * 2)) * 120 + 40; // 在金黄色到蓝色间波动
            }

            draw(ctx) {
                // 绘制自适应柔性形态 (软体线段)
                ctx.beginPath();
                ctx.moveTo(this.position.x, this.position.y);
                
                const speedScale = this.velocity.mag() / this.maxSpeed;
                ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${0.5 + speedScale * 0.5})`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                for (let i = this.history.length - 1; i >= 0; i--) {
                    ctx.lineTo(this.history[i].x, this.history[i].y);
                }
                ctx.stroke();

                // 绘制头部高亮节点
                ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 0.8)`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * 环境控制器 (Environment Controller)
         * 管理画布渲染、高清适配与交互响应
         */
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let boids = [];
        let mouse = { x: 0, y: 0, active: false, speed: 0, lastX: 0, lastY: 0 };
        let isClicking = false;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(dpr, dpr);
            
            // 重新初始化鸟群以适应新视口
            if (boids.length === 0) {
                for (let i = 0; i < 180; i++) {
                    boids.push(new Boid(window.innerWidth, window.innerHeight));
                }
            }
        }

        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', (e) => {
            mouse.active = true;
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            // 计算鼠标移动速度
            mouse.speed = Math.sqrt((mouse.x - mouse.lastX)**2 + (mouse.y - mouse.lastY)**2);
            mouse.lastX = mouse.x;
            mouse.lastY = mouse.y;
        });
        window.addEventListener('mousedown', () => isClicking = true);
        window.addEventListener('mouseup', () => isClicking = false);
        window.addEventListener('mouseleave', () => mouse.active = false);

        function animate() {
            // 尾迹渲染 (Trail Effect)
            // 不完全清空，而是覆盖一层带透明度的蒙版
            ctx.fillStyle = 'rgba(5, 5, 5, 0.15)'; 
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            for (let boid of boids) {
                boid.flock(boids, mouse, isClicking);
                boid.update(window.innerWidth, window.innerHeight);
                boid.draw(ctx);
            }

            requestAnimationFrame(animate);
        }

        // 初始启动
        resize();
        animate();
    </script>
</body>
</html>