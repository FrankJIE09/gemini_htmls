<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Hand Particles - Gemini 3</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', monospace;
            user-select: none;
        }

        /* 赛博朋克背景网格与扫描线 */
        #background-fx {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        
        /* 扫描线动画 */
        #scanline {
            width: 100%;
            height: 100px;
            z-index: 1;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 255, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }

        /* 暗角效果 */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: 0 0 150px rgba(0,0,0,0.9) inset;
            pointer-events: none;
            z-index: 2;
        }

        /* HUD 界面 */
        .hud-panel {
            position: absolute;
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            padding: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 10, 20, 0.6);
            backdrop-filter: blur(2px);
        }

        #hud-tl { top: 20px; left: 20px; border-top-left-radius: 10px; }
        #hud-tr { top: 20px; right: 20px; border-top-right-radius: 10px; text-align: right; }
        #hud-bl { bottom: 20px; left: 20px; border-bottom-left-radius: 10px; }
        #hud-br { bottom: 20px; right: 20px; border-bottom-right-radius: 10px; text-align: right; }

        .label {
            font-size: 10px;
            color: rgba(0, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .value {
            font-size: 18px;
            font-weight: bold;
        }
        .status-active { color: #f0f; text-shadow: 0 0 5px #f0f; }
        .instruction { color: #ff0; font-size: 12px; margin-top: 5px; opacity: 0.8; }

        #canvas-container {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>

    <div id="background-fx"></div>
    <div id="scanline"></div>
    <div id="vignette"></div>

    <!-- HUD Elements -->
    <div id="hud-tl" class="hud-panel">
        <div class="label">SYSTEM STATUS</div>
        <div id="fps-counter" class="value">60 FPS</div>
        <div class="label">PARTICLES</div>
        <div class="value">25,000 UNIT</div>
    </div>

    <div id="hud-tr" class="hud-panel">
        <div class="label">LEFT HAND (CMD)</div>
        <div id="left-hand-status" class="value">IDLE</div>
        <div class="instruction">KEYS: 1, 2, 3, 4, 5</div>
    </div>

    <div id="hud-bl" class="hud-panel">
        <div class="label">INTERACTION MODE</div>
        <div id="interaction-mode" class="value">SCATTER</div>
        <div class="instruction">SPACEBAR: NEBULA/RIPPLE</div>
    </div>

    <div id="hud-br" class="hud-panel">
        <div class="label">RIGHT HAND (PHYSICS)</div>
        <div id="right-hand-status" class="value">INDEX FINGER</div>
        <div class="instruction">MOUSE: TRACKING</div>
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 全局配置 ---
        const CONFIG = {
            particleCount: 25000,
            particleSize: 3.0,
            returnSpeed: 0.16,
            scatterForce: 50,      // 强力散开力度
            rippleAmplitude: 30,   // 水波纹幅度
            textFontSize: 120,     // 文字扫描字号
            colors: {
                blue: new THREE.Color(0x00FFFF),
                yellow: new THREE.Color(0xFFFF00),
                pink: new THREE.Color(0xFF00FF),
                green: new THREE.Color(0x00FF88),
                orange: new THREE.Color(0xFF8800),
                default: new THREE.Color(0x00FFFF)
            }
        };

        // --- 状态管理 ---
        const STATE = {
            leftHandMode: 1, // 1, 2, 3, 4, 5
            rightHandOpen: false, // controlled by Spacebar
            mouseX: 0,
            mouseY: 0,
            simulatedLeftHandPos: new THREE.Vector3(-200, 0, 0), // 左手盛接位置
            isBasketballMode: false
        };

        // --- Three.js 核心变量 ---
        let scene, camera, renderer, particles, geometry;
        let originalPositions = []; // 目标位置缓存
        let currentPositions = [];  // 当前物理位置
        let particleColors = [];    // 颜色数据
        let targetPositions = [];   // 目标位置
        let bounceOffsets = [];     // 篮球弹跳偏移量
        
        // 字体画布
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');
        textCanvas.width = 1024;
        textCanvas.height = 512;

        // 初始化
        function init() {
            const container = document.getElementById('canvas-container');
            
            // 场景
            scene = new THREE.Scene();
            // 稍微加一点雾气增强景深
            scene.fog = new THREE.FogExp2(0x000000, 0.0005);

            // 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 800;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // 创建粒子系统
            createParticles();

            // 生成初始目标 (Mode 1: Hello)
            generateTextTarget("Hello", CONFIG.colors.blue);

            // 事件监听
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            // 动画循环
            animate();
        }

        // 创建粒子
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // 初始随机位置 (Nebula style)
                positions[i * 3] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 1000;

                colors[i * 3] = CONFIG.colors.blue.r;
                colors[i * 3 + 1] = CONFIG.colors.blue.g;
                colors[i * 3 + 2] = CONFIG.colors.blue.b;

                sizes[i] = CONFIG.particleSize;

                // 初始化物理数组
                currentPositions.push(new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]));
                targetPositions.push(new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]));
                bounceOffsets.push(0);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 材质
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        // 简单的圆形发光粒子
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        // 边缘柔化
                        float alpha = 1.0 - (r * 2.0);
                        alpha = pow(alpha, 1.5); 
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 目标生成逻辑 ---

        // 1. 文字生成 (Canvas 扫描法)
        function generateTextTarget(text, color) {
            STATE.isBasketballMode = false;
            
            // 清空并绘制文字
            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            textCtx.font = `bold ${CONFIG.textFontSize}px "Microsoft YaHei", sans-serif`; // 支持中文
            textCtx.fillStyle = '#FFFFFF';
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            textCtx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

            const imageData = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
            const data = imageData.data;
            const validPixels = [];

            // 扫描像素
            for (let y = 0; y < textCanvas.height; y += 2) { // 采样步长（更密集）
                for (let x = 0; x < textCanvas.width; x += 2) {
                    const index = (y * textCanvas.width + x) * 4;
                    if (data[index] > 128) { // 亮度阈值
                        validPixels.push({
                            x: (x - textCanvas.width / 2) * 3, // 缩放因子
                            y: -(y - textCanvas.height / 2) * 3
                        });
                    }
                }
            }

            updateTargets(validPixels, color);
        }

        // 2. 星云模式 (全屏散布)
        function generateNebulaTarget() {
            STATE.isBasketballMode = false;
            const nebulaTargets = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                nebulaTargets.push({
                    x: (Math.random() - 0.5) * window.innerWidth * 1.5,
                    y: (Math.random() - 0.5) * window.innerHeight * 1.5,
                    z: (Math.random() - 0.5) * 500
                });
            }
            // 保持当前颜色或设为默认
            updateTargets(nebulaTargets, null, true); 
        }

        // 3. 篮球模式 (斐波那契球面 + 弹跳轨迹预设)
        function generateBasketballTarget() {
            STATE.isBasketballMode = true;
            const radius = 120; // 篮球半径
            const targets = [];
            const phi = Math.PI * (3 - Math.sqrt(5)); // 黄金角

            const offset = STATE.simulatedLeftHandPos; // 汇聚到左手

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const y = 1 - (i / (CONFIG.particleCount - 1)) * 2; // y goes from 1 to -1
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = phi * i;

                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;

                // 纹理模拟：黑线区域粒子少或颜色深 (简单模拟：根据坐标排除切片)
                // 这里为了视觉完整，不做复杂纹理剔除，而是用颜色纹理
                
                targets.push({
                    x: x * radius + offset.x,
                    y: y * radius + offset.y,
                    z: z * radius + offset.z
                });

                // 设置弹跳随机相位
                bounceOffsets[i] = Math.random() * Math.PI; 
            }
            
            // 橙色为主，混入黑色线条颜色
            updateTargets(targets, CONFIG.colors.orange, false, true);
        }

        // 更新目标位置数组
        function updateTargets(validPoints, color, isNebula = false, isBasketball = false) {
            const colorAttr = geometry.attributes.color;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // 目标位置分配
                let target;
                if (validPoints.length > 0) {
                    const p = validPoints[i % validPoints.length];
                    target = isNebula ? p : { x: p.x, y: p.y, z: p.z || 0 };
                } else {
                    target = { x: 0, y: 0, z: 0 };
                }
                
                targetPositions[i].set(target.x, target.y, target.z || 0);

                // 颜色更新
                if (color) {
                    let c = color;
                    // 篮球纹理处理
                    if (isBasketball) {
                        // 简单的条纹生成逻辑
                        const p = targetPositions[i];
                        const localY = p.y - STATE.simulatedLeftHandPos.y;
                        const localX = p.x - STATE.simulatedLeftHandPos.x;
                        if (Math.abs(localY) < 5 || Math.abs(localX) < 5) {
                            c = new THREE.Color(0x111111); // 黑线
                        } else {
                            c = CONFIG.colors.orange;
                        }
                    }

                    colorAttr.setXYZ(i, c.r, c.g, c.b);
                }
            }
            colorAttr.needsUpdate = true;
        }

        // --- 交互处理 ---

        function onMouseMove(event) {
            // 将鼠标坐标转换为 Three.js 坐标系
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // 简单的投影，假设 Z=0
            const vector = new THREE.Vector3(x, y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            STATE.mouseX = pos.x;
            STATE.mouseY = pos.y;
        }

        function onKeyDown(event) {
            const key = event.key;
            
            // 左手逻辑 (1-5)
            if (['1', '2', '3', '4', '5'].includes(key)) {
                STATE.leftHandMode = parseInt(key);
                updateLeftHandState();
            }

            // 右手逻辑 (Space)
            if (event.code === 'Space') {
                if (!STATE.rightHandOpen) {
                    STATE.rightHandOpen = true;
                    updateRightHandState();
                }
            }
        }

        function onKeyUp(event) {
            if (event.code === 'Space') {
                STATE.rightHandOpen = false;
                updateRightHandState();
            }
        }

        function updateLeftHandState() {
            const mode = STATE.leftHandMode;
            const hud = document.getElementById('left-hand-status');

            // 检查组合技
            if (checkCombo()) return;

            switch(mode) {
                case 1:
                    generateTextTarget("Hello", CONFIG.colors.blue);
                    hud.innerText = "1 FINGER (HELLO)";
                    hud.style.color = '#0ff';
                    break;
                case 2:
                    generateTextTarget("Gemini3", CONFIG.colors.yellow);
                    hud.innerText = "2 FINGERS (MODEL)";
                    hud.style.color = '#ff0';
                    break;
                case 3:
                    generateTextTarget("非常好用", CONFIG.colors.pink);
                    hud.innerText = "3 FINGERS (PRAISE)";
                    hud.style.color = '#f0f';
                    break;
                case 4:
                    generateTextTarget("再见", CONFIG.colors.green);
                    hud.innerText = "4 FINGERS (BYE)";
                    hud.style.color = '#0f8';
                    break;
                case 5:
                    // 盛接模式：准备接收，但如果右手没张开，则只是清空或维持
                    // 这里设计为先显示一个容器提示，或者保持原状等待
                    generateTextTarget("[  READY  ]", CONFIG.colors.default);
                    hud.innerText = "5 FINGERS (CATCH MODE)";
                    hud.style.color = '#fff';
                    break;
            }
        }

        function updateRightHandState() {
            const hud = document.getElementById('right-hand-status');
            const hudMode = document.getElementById('interaction-mode');
            
            // 检查组合技
            if (checkCombo()) return;

            if (STATE.rightHandOpen) {
                // Nebula / Ripple Mode
                generateNebulaTarget(); 
                hud.innerText = "HAND OPEN";
                hudMode.innerText = "NEBULA / RIPPLE";
                hudMode.className = "value status-active";
            } else {
                // Back to previous text
                updateLeftHandState(); 
                hud.innerText = "INDEX FINGER";
                hudMode.innerText = "SCATTER (PHYSICS)";
                hudMode.className = "value";
            }
        }

        function checkCombo() {
            // 只有当左手为5且右手张开时触发
            if (STATE.leftHandMode === 5 && STATE.rightHandOpen) {
                generateBasketballTarget();
                document.getElementById('interaction-mode').innerText = "ULTIMATE: BASKETBALL";
                document.getElementById('interaction-mode').style.color = "#ff8800";
                return true;
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 核心动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;
            const time = Date.now() * 0.001;
            
            // 右手交互点
            const mousePos = new THREE.Vector3(STATE.mouseX, STATE.mouseY, 0);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let current = currentPositions[i];
                let target = targetPositions[i];

                // 1. 基础运动 (Lerp)
                // 篮球模式下的特殊弹跳轨迹
                if (STATE.isBasketballMode) {
                    // 增加旋转
                    const speed = 2.0;
                    const x = target.x - STATE.simulatedLeftHandPos.x;
                    const z = target.z - STATE.simulatedLeftHandPos.z;
                    // 绕Y轴旋转
                    const rotatedX = x * Math.cos(speed * 0.01) - z * Math.sin(speed * 0.01);
                    const rotatedZ = x * Math.sin(speed * 0.01) + z * Math.cos(speed * 0.01);
                    
                    target.x = rotatedX + STATE.simulatedLeftHandPos.x;
                    target.z = rotatedZ + STATE.simulatedLeftHandPos.z;
                    
                    // 弹跳效果模拟 (实际上在飞入过程中很难模拟单个弹跳，这里做成旋转球体的呼吸效果)
                    const bounce = Math.sin(time * 5 + bounceOffsets[i]) * 5;
                    target.y += bounce * 0.05; 
                }

                current.x += (target.x - current.x) * CONFIG.returnSpeed;
                current.y += (target.y - current.y) * CONFIG.returnSpeed;
                current.z += (target.z - current.z) * CONFIG.returnSpeed;

                // 2. 右手物理交互
                const dist = current.distanceTo(mousePos);
                
                if (STATE.rightHandOpen) {
                    // 状态 B: 涟漪 (Ripple)
                    // 只有当粒子接近右手划过的区域时触发
                    if (dist < 300) {
                        // Z轴波浪
                        current.z += Math.sin(dist * 0.1 - time * 10) * CONFIG.rippleAmplitude * (1 - dist/300);
                    }
                } else {
                    // 状态 A: 强力斥力 (Scatter) - 仅平面推开
                    if (dist < 150) {
                        const force = (150 - dist) / 150;
                        const angle = Math.atan2(current.y - mousePos.y, current.x - mousePos.x);
                        const moveX = Math.cos(angle) * CONFIG.scatterForce * force;
                        const moveY = Math.sin(angle) * CONFIG.scatterForce * force;
                        
                        current.x += moveX;
                        current.y += moveY;
                        // 不改变 Z 轴，保持平面整洁
                    }
                }

                // 更新 Buffer
                positions[i * 3] = current.x;
                positions[i * 3 + 1] = current.y;
                positions[i * 3 + 2] = current.z;
            }

            geometry.attributes.position.needsUpdate = true;

            // 篮球自转整体效果 (通过旋转相机或者整体容器也可以，但这里我们旋转了目标点)
            
            // 更新 HUD FPS (模拟)
            if (Math.random() > 0.95) {
                document.getElementById('fps-counter').innerText = Math.floor(58 + Math.random() * 4) + " FPS";
            }

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>
